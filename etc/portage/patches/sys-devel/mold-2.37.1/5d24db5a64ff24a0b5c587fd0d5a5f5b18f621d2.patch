From 5d24db5a64ff24a0b5c587fd0d5a5f5b18f621d2 Mon Sep 17 00:00:00 2001
From: Rui Ueyama <ruiu@cs.stanford.edu>
Date: Wed, 2 Apr 2025 17:19:22 +0900
Subject: [PATCH] Handle COMDAT symbols in LTO IR object files

Before 9306f69a615bd54814263c59a9ff7f78a205753a, we completely ignored
duplciate symbol errors in IR object files. After that commit, we've
been accidentally reporting duplicate comdat symbols as errors.

Fixes https://github.com/rui314/mold/issues/1434
---
 src/input-files.cc | 12 +++++++++---
 src/lto-unix.cc    |  8 ++++++++
 src/mold.h         |  4 ++++
 src/passes.cc      | 12 +++++++++++-
 test/lto-comdat.sh | 27 +++++++++++++++++++++++++++
 5 files changed, 59 insertions(+), 4 deletions(-)
 create mode 100755 test/lto-comdat.sh

diff --git a/src/input-files.cc b/src/input-files.cc
index bdda405b8c..fa50c30be1 100644
--- a/src/input-files.cc
+++ b/src/input-files.cc
@@ -282,6 +282,13 @@ std::vector<ElfRel<E>> decode_crel(Context<E> &ctx, ObjectFile<E> &file,
   return vec;
 }
 
+template <typename E>
+ComdatGroup *insert_comdat_group(Context<E> &ctx, std::string_view name) {
+  typename decltype(ctx.comdat_groups)::const_accessor acc;
+  ctx.comdat_groups.insert(acc, {name, ComdatGroup()});
+  return const_cast<ComdatGroup *>(&acc->second);
+}
+
 template <typename E>
 void ObjectFile<E>::initialize_sections(Context<E> &ctx) {
   // Read sections
@@ -340,9 +347,7 @@ void ObjectFile<E>::initialize_sections(Context<E> &ctx) {
       if (entries[0] != GRP_COMDAT)
         Fatal(ctx) << *this << ": unsupported SHT_GROUP format";
 
-      typename decltype(ctx.comdat_groups)::const_accessor acc;
-      ctx.comdat_groups.insert(acc, {signature, ComdatGroup()});
-      ComdatGroup *group = const_cast<ComdatGroup *>(&acc->second);
+      ComdatGroup *group = insert_comdat_group(ctx, signature);
       comdat_groups.push_back({group, (i32)i, entries.subspan(1)});
       break;
     }
@@ -1523,6 +1528,7 @@ template class SharedFile<E>;
 template Symbol<E> *get_symbol(Context<E> &, std::string_view, std::string_view);
 template Symbol<E> *get_symbol(Context<E> &, std::string_view);
 template std::string_view demangle(const Symbol<E> &);
+template ComdatGroup *insert_comdat_group(Context<E> &, std::string_view);
 template std::ostream &operator<<(std::ostream &, const Symbol<E> &);
 template std::ostream &operator<<(std::ostream &, const InputFile<E> &);
 
diff --git a/src/lto-unix.cc b/src/lto-unix.cc
index 73dcd6f913..3552133483 100644
--- a/src/lto-unix.cc
+++ b/src/lto-unix.cc
@@ -654,6 +654,7 @@ ObjectFile<E> *read_lto_object(Context<E> &ctx, MappedFile *mf) {
 
   // Initialize esyms
   obj->lto_elf_syms.resize(plugin_symbols.size() + 1);
+  obj->lto_comdat_groups.resize(plugin_symbols.size() + 1);
   i64 strtab_offset = 1;
 
   for (i64 i = 0; i < plugin_symbols.size(); i++) {
@@ -664,6 +665,13 @@ ObjectFile<E> *read_lto_object(Context<E> &ctx, MappedFile *mf) {
     i64 len = strlen(psym.name);
     memcpy(strtab.data() + strtab_offset, psym.name, len);
     strtab_offset += len + 1;
+
+    // comdat_key is non-null if the symbol is defined in a comdat member
+    // section. We handle such symbols differently than comdat symbols in
+    // a regular file because, unlike regular object files, IR files don't
+    // have input sections.
+    if (psym.comdat_key)
+      obj->lto_comdat_groups[i + 1] = insert_comdat_group(ctx, psym.comdat_key);
   }
 
   obj->symbol_strtab = save_string(ctx, strtab);
diff --git a/src/mold.h b/src/mold.h
index 3dcd09776d..73209e1ed9 100644
--- a/src/mold.h
+++ b/src/mold.h
@@ -1444,6 +1444,7 @@ class ObjectFile : public InputFile<E> {
 
   // For LTO
   std::vector<ElfSym<E>> lto_elf_syms;
+  std::vector<ComdatGroup *> lto_comdat_groups;
 
 private:
   void initialize_sections(Context<E> &ctx);
@@ -2507,6 +2508,9 @@ Symbol<E> *get_symbol(Context<E> &ctx, std::string_view key,
 template <typename E>
 Symbol<E> *get_symbol(Context<E> &ctx, std::string_view name);
 
+template <typename E>
+ComdatGroup *insert_comdat_group(Context<E> &ctx, std::string_view name);
+
 template <typename E>
 std::string_view demangle(const Symbol<E> &sym);
 
diff --git a/src/passes.cc b/src/passes.cc
index 1a62079446..2061a5d753 100644
--- a/src/passes.cc
+++ b/src/passes.cc
@@ -288,9 +288,13 @@ void resolve_symbols(Context<E> &ctx) {
     // we could eliminate a symbol that is already resolved to and cause
     // dangling references.
     tbb::parallel_for_each(ctx.objs, [](ObjectFile<E> *file) {
-      if (file->is_reachable)
+      if (file->is_reachable) {
         for (ComdatGroupRef<E> &ref : file->comdat_groups)
           update_minimum(ref.group->owner, file->priority);
+        for (ComdatGroup *g : file->lto_comdat_groups)
+          if (g)
+            update_minimum(g->owner, file->priority);
+      }
     });
 
     tbb::parallel_for_each(ctx.objs, [](ObjectFile<E> *file) {
@@ -1055,6 +1059,12 @@ void check_duplicate_symbols(Context<E> &ctx) {
           continue;
       }
 
+      // Skip if the symbol is a comdat symbol that is in an IR file.
+      if (file->is_lto_obj)
+        if (ComdatGroup *g = file->lto_comdat_groups[i])
+          if (g->owner != file->priority)
+            continue;
+
       Error(ctx) << "duplicate symbol: " << *file << ": " << *sym.file
                  << ": " << sym;
     }
diff --git a/test/lto-comdat.sh b/test/lto-comdat.sh
new file mode 100755
index 0000000000..201c52ca46
--- /dev/null
+++ b/test/lto-comdat.sh
@@ -0,0 +1,27 @@
+#!/bin/bash
+. $(dirname $0)/common.inc
+
+[ $MACHINE = $(uname -m) ] || skip
+
+echo '' | clang -S -emit-llvm -flto -o $t/a.ll -xc - || skip
+
+cp $t/a.ll $t/b.ll
+
+cat <<'EOF' >> $t/b.ll
+$foo = comdat any
+@foo = global i32 42, comdat($foo)
+EOF
+
+cp $t/b.ll $t/c.ll
+
+clang -S -emit-llvm -flto -o $t/b.bc $t/b.ll
+clang -S -emit-llvm -flto -o $t/c.bc $t/c.ll
+
+cat <<'EOF' | clang -o $t/d.o -c -flto -xc -
+#include <stdio.h>
+extern int foo;
+int main() { printf("%d\n", foo); }
+EOF
+
+clang -B. -o $t/exe -flto $t/b.bc $t/c.bc $t/d.o
+$QEMU $t/exe | grep 42
